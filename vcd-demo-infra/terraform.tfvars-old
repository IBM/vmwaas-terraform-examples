# Note. Variable values to access your Director instance. Use the Director portal
# to figure our your values here.

#vmwaas_url = "https://dirw026.us-south.vmware.cloud.ibm.com/api"
#vmwaas_org = "f37f6631-e6c4-427e-b277-9fec446b88fb"
#vmwaas_vdc_name = "vdc-1k"
#vmwaas_vdc_name = "vdc-sami"


vmwaas_url = "https://dirw002.eu-de.vmware.cloud.ibm.com/api"
vmwaas_org = "8db98de2-7735-41f1-a487-64fcaefde250"
#vmwaas_vdc_name = "vdc-jw-sami"
vmwaas_vdc_name = "vdc-sami"


vmwaas_user = "sami.kuronen@fi.ibm.com"
#vmwaas_password = "Tu0pp3r0vmware123"
vmwaas_api_token = "PnKZKD95YC4xK5bXRRuXLvUPqYDAOQDu"


# Note. Use a common name prefix for each item. 

item_name_prefix = "sami-demo"

# Note. IBM Cloud DNS servers listed here. 
# You may also use your own here. 

dns_servers = ["161.26.0.10","161.26.0.11"] 


# Note. Create virtual data center networks of type `routed` or
# `isolated`. You can define one `static_ip_pool`and one
# `dhcp_ip_pool` for each.

vdc_networks = {
    application-network-1 = {
        description = "Application network 1"
        type = "routed"
        subnet = {
            cidr = "172.26.1.0/24"
            prefix_length = 24
            gateway = "172.26.1.1"
            static_ip_pool = {
                start_address = "172.26.1.10"
                end_address   = "172.26.1.100"
            }
            dhcp_ip_pool = {
                start_address = "172.26.1.101"
                end_address   = "172.26.1.199"
            }        
        }
    },
    db-network-1 = {
        description = "DB network 1"
        type = "routed"
        subnet = {
            cidr = "172.26.2.0/24"
            prefix_length = 24
            gateway = "172.26.2.1"
            static_ip_pool = {
                start_address = "172.26.2.10"
                end_address   = "172.26.2.100"
            }
            dhcp_ip_pool = {
                start_address = "172.26.2.101"
                end_address   = "172.26.2.199"
            }        
        }
    },
}


# Note. Create virtual machines inside your virtual data center.
# You can define each one idividually and attach multiple networks
# and disks. Individual disks are created for each additional disk.

# Note. Check the storage profile names and apply to your VMs / disks.
# If left empty, default profile is used.

virtual_machines = {
#/*
    app-server-1 = {
        image = {
            catalog_name  = "Public Catalog"
            template_name = "RedHat-8-Template-Official"
        }
        memory          = 8192
        cpus            = 2
        cpu_hot_add_enabled = true
        memory_hot_add_enabled = true
        storage_profile = ""
        networks = {
            0 = {
                name = "application-network-1"
                ip_allocation_mode = "POOL"
                is_primary = true
                ip = ""
            },
        }
        disks = {
            0 = {
                name = "logDisk"
                size_in_mb = "2000"
                bus_type = "SCSI"
                bus_sub_type = "VirtualSCSI"
                bus_number = 1
                storage_profile = ""
            },
        }
    },
    app-server-2 = {
        image = {
            catalog_name  = "Public Catalog"
            template_name = "RedHat-8-Template-Official"
        }
        memory          = 8192
        cpus            = 2
        cpu_hot_add_enabled = true
        memory_hot_add_enabled = true
        storage_profile = "2 IOPS/GB"
        networks = {
            0 = {
                name = "application-network-1"
                ip_allocation_mode = "POOL"
                is_primary = true
                ip = ""
            },
        }
        disks = {
            0 = {
                name = "logDisk"
                size_in_mb = "2000"
                bus_type = "SCSI"
                bus_sub_type = "VirtualSCSI"
                bus_number = 1
                storage_profile = ""
            },
        }
    },
    proxy-server-1 = {
        image = {
            catalog_name  = "Public Catalog"
            template_name = "RedHat-8-Template-Official"
        }
        memory        = 8192
        cpus          = 2
        cpu_hot_add_enabled = true
        memory_hot_add_enabled = true
        storage_profile = "2 IOPS/GB"
        networks = {
            0 = {
                name = "application-network-1"
                ip_allocation_mode = "DHCP"
                is_primary = true
                ip = ""
            },
        },
        disks = {}
    },
}




# Note. Map of available 6 public IPs. You can use these names
# in NAT rules.


public_ips = {
    public-ip-0 = {
      name = "public-ip-0"
      description = ""
    },
    public-ip-1 = {
      name = "public-ip-1" 
      description = ""
    },
    public-ip-2 = {
      name = "public-ip-2" 
      description = ""
    },
    public-ip-3 = {
      name = "public-ip-3" 
      description = ""
    },
    public-ip-4 = {
      name = "public-ip-4" 
      description = ""
    },
    public-ip-5 = {
      name = "public-ip-5" 
      description = ""
    },
}

# Note. You can use `vdc_networks` or `virtual_machines` keys as 
# address_targets here. Terraform will pick the IP address of 
# the specific resource and use that in the actual NAT rule.

# Note. You can specify the desired actual public IP address 
# (`external_address`) in the rule, or you can use the 
# `external_address_list_index`, which will pick the IP 
# addresss from the allocated IP pool (`edge_gateway_allocated_ips`). 

# Note. Use Director UI to get the name for the Application
# profiles."

nat_rules = {
/*
    no-snat-to-ibm-cloud-166-9 = {
        rule_type   = "NO_SNAT"
        description = "NO_SNAT rule to application-network-1"
        external_address_target = ""
        external_address = ""  
        internal_address_target = "application-network-1"
        internal_address = ""
        snat_destination_address = "166.9.0.0/16"
        logging = false
        priority = 10
        enabled = true
    },
    no-snat-to-ibm-cloud-161-26 = {
        rule_type   = "NO_SNAT"
        description = "NO_SNAT rule to application-network-1"
        external_address_target = ""
        external_address = ""  
        internal_address_target = "application-network-1"
        internal_address = ""
        snat_destination_address = "161.26.0.0/16"
        logging = false
        priority = 10
        enabled = true
    },
*/
    dnat-to-proxy-1 = {
        rule_type   = "DNAT"
        description = "DNAT rule to proxy-server-1"
        external_address_target = "public-ip-1"
        external_address = "" 
        internal_address_target = "proxy-server-1"
        internal_address = ""
        dnat_external_port = ""
        app_port_profile = ""
        logging = false
        priority = 90
        enabled = true
    },
    snat-to-internet-1 = {
        rule_type = "SNAT"
        description = "SNAT rule to application-network-1"
        external_address_target = "public-ip-0"
        external_address = ""  
        internal_address_target = "application-network-1"
        internal_address = ""
        snat_destination_address = ""
        logging = false
        priority = 100
        enabled = true
    },    
  }  


# Note. You need to create IP sets to be used in firewall rules.
# You can use the `public_ips`keys here as address_targets,
# you you can define `ip_addresses`.

ip_sets = {
    ip-set-on-public-ip-0 = {
      description = "Public IP 0 - used for SNAT"
      ip_addresses = []
      address_target = ["public-ip-0"]
    },
    ip-set-on-public-ip-1 = {
      description = "Public IP 1 - used for DNAT to proxy-server-1"
      ip_addresses = []
      address_target = ["public-ip-1"]
    },
    ip-set-on-public-ip-2 = {
      description = "Public IP 2"
      ip_addresses = []
      address_target = ["public-ip-2"]
    },
    ip-set-on-public-ip-3 = {
      description = "Public IP 3"
      ip_addresses = []
      address_target = ["public-ip-3"]
    },
    ip-set-on-public-ip-4 = {
      description = "Public IP 4"
      ip_addresses = []
      address_target = ["public-ip-4"]
    },
    ip-set-on-public-ip-5 = {
      description = "Public IP 5"
      ip_addresses = []
      address_target = ["public-ip-5"]
    },
    ip-set-on-premises-networks = {
      description = "On-premises networks"
      ip_addresses = ["172.16.0.0/16",]
      address_target = []
    },
    ip-set-on-sami = {
      description = "Public IPs"
      ip_addresses = []
      address_target = ["public-ip-0","public-ip-1"]
    },
}

# Note. You need to create Static Groups to be used in firewall rules.
# You can use `vdc_networks` as keys here.

security_groups = {
    sg-application-network-1 = {
      description = "Static Group for application-network-1"
      address_targets = ["application-network-1"]
    },
}


# Note. Use "ALLOW or "DROP".

# Note. Use Director UI to get the name for the Application
# profiles."

firewall_rules = {
    app-1-egress = {
        action  = "ALLOW"
        direction = "OUT"
        ip_protocol = "IPV4"
        destinations = []                                          # These refer to IP sets (ip_sets or nat_rules) or Static Groups (vdc_networks)
        sources = ["sg-application-network-1"]  # These refer to IP sets (ip_sets or nat_rules) or Static Groups (vdc_networks)
        system_app_ports = []
        logging = false
        enabled = true
    },
    dnat-to-proxy-1-ingress = {
        action  = "ALLOW"
        direction = "IN"
        ip_protocol = "IPV4"
        destinations = ["ip-set-on-public-ip-1"]                   # These refer to IP sets (ip_sets or nat_rules) or Static Groups (vdc_networks)
        sources = []                                               # These refer to IP sets (ip_sets or nat_rules) or Static Groups (vdc_networks)
        system_app_ports = ["SSH","HTTPS","ICMP ALL"]
        logging = false
        enabled = true
    },
}

